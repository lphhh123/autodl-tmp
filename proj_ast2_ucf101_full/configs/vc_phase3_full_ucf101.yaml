_base_: version_c_ucf101.yaml

stable_hw:
  enabled: true
  baseline_stats_path: "outputs/dense_baseline/metrics.json"
  hw_ref_source: "baseline_stats"
  locked_acc_ref:
    enabled: true
    source: "warmup_best"
    acc_ref1: 0.0
    acc_ref5: 0.0
    strict: true
    # IMPORTANT: do NOT lock acc_ref on epoch0/1; it is too noisy and causes permanent VIOLATE.
    # Align with AST warmup (ast.schedule.warmup_epochs=15) so discrete updates are allowed early.
    freeze_epoch: 15
  no_drift:
    enabled: true
    allow_update: false
    stats_path: "${out_dir}/baseline_stats.json"
  no_double_scale:
    enabled: true
  force_disable_ok: false

  allow_train_ema_fallback: true

  lambda_hw_schedule:
    enabled: true
    # Start HW schedule only after accuracy reference is frozen (freeze_epoch=15).
    warmup_epochs: 15
    ramp_epochs: 10
    lambda_hw_min: 0.0
    lambda_hw_max: 0.08

  normalize:
    enabled: true
    mode: hinge_log_ratio
    eps: 1.0e-6
    wT: 0.4
    wE: 0.2
    wM: 0.2
    wC: 0.2
    target_ratio_T: 0.9
    target_ratio_E: 0.9
    mem_hinge_only: true
    clip_term_max: 10.0

  accuracy_guard:
    enabled: true
    controller:
      metric: val_acc1
      # Too strict + noisy fast-val (20 batches) => permanent VIOLATE. Relax and add hysteresis.
      epsilon_drop: 0.01
      hysteresis: 0.002
      cut_hw_loss_on_violate: true
      freeze_discrete_updates: true
      freeze_schedule_in_recovery: true
      recovery_min_epochs: 2
      k_exit: 2
      margin_exit: 0.0

  discrete_isolation:
    mapping_update_every_epochs: 1
    layout_update_every_epochs: 1
    use_cached_mapping_for_inner_steps: true
    use_cached_layout_for_inner_steps: true
    track_live_in_inner_steps: false
train:
  mode: version_c
